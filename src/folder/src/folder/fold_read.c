#include <folder.h>

int fold_read(int folder_Id,int* org_folderId,void *user_buffer,
                 int nsize,int fBlocked)
{
    //Description:  this function reads application data from a given folder
    //Argument:     folder_Id       folder to read from
    //              org_folderId    if successful,the sender's folder id 
    //                              will be put into this address
    //              user_buffer     a buffer to hold application data received
    //              nsize           the size of buffer 'user_buffer'
    //              fBlocked        if set, function will process in blocked 
    //                              mode,or nonblocked mode
    //Return value: if successful, this function returns the real bytes 
    //              number received and put into buffer 'user_buffer';
    //              if failed,-1 will be returnd and  errno specifies detailed
    //              failure cause:
    //              FOLD_ENOSYS   the caller not attached to Folder system
    //              FOLD_EINVAL   invalid argument in function call
    //              FOLD_ENOENT   specified folder not existing
    //              ENOMSG        no data readable in folder at present
    //              EINTR         the reading operating is interrupted 
    //                            by a Unix signal       
    //              other valude  other error code generated by Unix
    
    struct msgpacket *pPkt,pkt;
    int    ret,fd;
    char logfile[300];
    if(fold_isattach() < 0)
    {
        errno = FOLD_ENOSYS;
        return -1;    
    }
     
    if(fold_check_Id(folder_Id) < 0)
    {
        errno = FOLD_ENOENT;
        return -1;    
    }
    
/*    pPkt = &gl_msgpacket; */
    memset(&pkt,0,sizeof(pkt));
    pPkt =&pkt;
    pPkt->msg_address = gl_pFldArray[folder_Id].fold_address;
    for(;;)
    {
        //wait the message packet
        pPkt->msg_clusterid = -1;
        ret = queue_recv(gl_pFldCtrl->msg_viaqid, pPkt, 
                   sizeof(struct msgpacket)-sizeof(long),!fBlocked);
 
        if(ret < 0)
        {
 /*						u_fabricatefile("log/foldtest.log",logfile,sizeof(logfile));
        	  fd = log_open(logfile);   
        	  log_jotdown(fd,"fold_read","foldid=%d, pre=%d,errno=%d\n",folder_Id,gl_pFldArray[folder_Id].fold_nmsg,errno);
*/          if(errno == EINTR)
            {
                if(gl_pFldArray[folder_Id].fold_flags & FOLD_FLAG_NEEDSIG)
                    return 0;
                else
                {
					            fold_lock_folder(folder_Id);
											if (gl_pFldArray[folder_Id].fold_nmsg > 0 )
													gl_pFldArray[folder_Id].fold_nmsg --;
											fold_unlock_folder(folder_Id);
											log_jotdown(fd,"fold_read","foldid=%d,bak=%d.\n",folder_Id,gl_pFldArray[folder_Id].fold_nmsg);  
							        close(fd); 
							        continue;
                }
            }
            else
            {
       	            fold_lock_folder(folder_Id);
										if (gl_pFldArray[folder_Id].fold_nmsg > 0 )
												gl_pFldArray[folder_Id].fold_nmsg --;
										fold_unlock_folder(folder_Id);
/*										log_jotdown(fd,"fold_read","foldid=%d,bak1=%d.\n",folder_Id,gl_pFldArray[folder_Id].fold_nmsg);  
						        close(fd); 
*/            	 	    return -1;
            }
         }

        if(org_folderId) 
            *org_folderId = pPkt->msg_org;
        fold_lock_folder(folder_Id);
        gl_pFldArray[folder_Id].fold_nmsg --;
        gl_msgpacket.msg_tickcount=pPkt->msg_tickcount;
        fold_unlock_folder(folder_Id);
        close(fd);  
        switch(pPkt->msg_command)
        {
            case FOLD_MSG_DATA:
                 {
                     //this packet refers to ordinary data,we will get it
                     int nread;
                     
                     if(pPkt->msg_clusterid < 0)
                         //no data associated with this message packet
                         return 0;  
        
                     //pick the data
                     if(nsize > 0 && user_buffer != NULL)
                         nread=mbuf_getdata(&gl_shmobj,
                                     pPkt->msg_clusterid,user_buffer,nsize);
    
                     //free the cluster if necessary
                     if(1)
                         mbuf_free(&gl_shmobj,pPkt->msg_clusterid);
        
                     return nread;
                 }
                 break;
                 
            case FOLD_MSG_PROBE_REQ:
                 {
                      //this packet is a probe request,we will send a ACK
                      fold_probe_ack(pPkt->msg_org,pPkt->msg_dest);
                      if(gl_pFldArray[folder_Id].fold_flags & FOLD_FLAG_NEEDSIG)
                          return 0;
                      else
                          ; //call queue_recv() again    
                 }
                 break;
                 
            case FOLD_MSG_PROBE_ACK:
            case FOLD_MSG_EXIT:
                 return 0;
                 
            default:   //unrecognizable message packet
                 return -1;  
         }//switch                       
     }//for(;;)
}

int fold_purge_msg(int foldId)
{
  char dummyBuf[128];

  for(;;)
    if(fold_read(foldId,NULL,dummyBuf,sizeof(dummyBuf),FALSE) <= 0)
      break;
}

int fold_msg_tickcount()
{
    return gl_msgpacket.msg_tickcount;
}
